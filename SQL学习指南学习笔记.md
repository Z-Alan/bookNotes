SQL 学习指南

## **1 背景知识**

### 1.1 主键的选择

* 自然主键
* 逻辑主键

### 1.2 术语表

|  术语  |                           定   义                            |
| :----: | :----------------------------------------------------------: |
|  实体  |       数据库用户所关注的对象，如顾客、部门、地理位置等       |
|   列   |                   存储在表中的独立数据片段                   |
|   行   | 所有列的一个集合，完整的描述了一个实体或实体上的某个行为，也称之为记录 |
|   表   | 行的集合，既可以保存在内存中（未持久化）,也可以保存在存储设备中（已持久化） |
| 结果集 |         未持久化表的另一个名字，一般为SQL查询的结果          |
|  主键  |             用于唯一标识表中每个行的一个或多个列             |
|  外键  |             一个或多个用于识别其他表中某一行的列             |

### 1.3 SQL 语句的分类

* SQL 方案（schema）语句
* SQL 数据语句
* SQL 事务语句


## **3  查询入门**

### 3.1 查询机制

【...】首先打开mysql命令行工具，然后使用用户名和密码登陆（如果MySQL服务器运行在另一台计算机上，还需要提供主机名）。一旦服务器通过了对用户名和密码的验证，则为用户创建一个数据库连接。该连接从应用程序（此处即为mysq工具）发出请求后一直保持，知道应用程序释放连接（比如输入quit命令）或者服务器关闭连接（比如服务器关机）。MySQL服务器会给每个连接赋予一个标识符，它会在首次登陆时显示。【...】

在服务器验证完用户名和密码，并且创建连接后，用户就可以执行查询了（当然也包括其他SQL语句）。每当查询被发送到服务端时，服务器在执行语句之前将会进行下面的检查：

* 用户是否有权限执行该语句
* 用户是否有权限访问目标数据
* 语句的语法是否正确

如果查询语句通过了这3个测试，就会被传递给查询优化器，它负责为查询找到最有效率的执行方式。优化器通常会做诸如确定from子句后面各表的连接顺序，或是可以使用哪些索引之类的工作，然后选择一个执行方案，以供服务器执行该查询。

> 对于很多读者来说，理解和影响数据库服务器来选择查询执行方案是一个极具吸引力的主题。对于使用MySQL的读者，建议阅读Baron Schwartz等人著作的High Performance MySQL 一书，其中介绍了如何建立索引、分析执行方案，通过查询提示（query hints ） 分析优化器以及调优服务器的初始参数等。

当服务器执行完查询以后，将会向调用程序（再次提示：本例中即mysql工具）返回一个结果集。

### 3.2 查询语句

select 语句有几个组件或者说子句构成。通常的查询语句会至少包括6个子句中的2~3个。

| 子句名称 | 使用目的                                     |
| -------- | -------------------------------------------- |
| select   | 确定结果集中应该包含哪些列                   |
| from     | 指明所要提取数据的表，以及这些表是如何连接的 |
| where    | 过滤不需要的数据                             |
| group by | 用于对具有相同列值的行进行分组               |
| order by | 按一个或多个列，对最后结果集中的行进行排序   |

### 3.3 select子句

##### select子句的作用

> select 子句用于在所有可能列中，选择查询结果集要包含哪些列

还可以在子句中使用如下几种方式：

* 字符，比如数据或字符串
* 表达式
* 调用内建函数
* 用户自定义的函数调用

#### 3.3.1 列的别名

可以通过在select子句的每个元素后面增加列别名，可以为一些特殊的列定义一个标签，可以在别名前加上可选关键字`as`来清晰地表示别名

#### 3.3.2 去除重复行

在select 关键字之后加上`distinct`关键字

```sql
SELECT DISTINCT cust_id
FROM account
```

##### **警告**

> 注意产生无重复地结果集需要首先对数据排序，这对于大的结果集来说是相当耗时地，因此不要为了确保去除重复行而随意地使用 `DISTINCT` ,而是应该先了解使用地数据是否可能包含重复行，以减少对 `DISTINCT`地不必要的使用

### 3.4 from 子句

> from 子句定义了查询中所使用的表，以及连接这些表的方式

#### 3.4.1 表的概念

在对 “表” 的宽泛的定义下，存在3中类型的表

* 永久表 （使用create table语句创建的表）
* 临时表（子查询所返回的表）
* 虚拟表 （使用create view 子句所创建的视图）



##### **子查询产生的表**

> 子查询指的是包含在另一个查询中的查询。子查询可以出现在select语句中的各个部分并且被包含在圆括号中。在from子句内，子查询的作用是根据其他查询子句（其中的from子句可以与其他表进行交互）产生临时表

##### **视图**

> 视图是存储在数据字典中的查询，它的行为表现的像一个表，但实际上并不用有任何数据，（所以称之为虚拟表）。当发出一个对视图的查询时，该查询会被绑定到视图定义上，以长产生最终被执行的查询

#### 3.4.2 表连接

> 如果 from 子句中出现了多个表，那么要求同时包含各表之间的连接条件。

#### 3.4.3 定义表别名

当在单个查询中连接多个表时，需要在select、where、group by 、having 以及order by子句中指明所引用的是哪个表。有两种在from子句之外引用表的方式：

* 使用完整的表名称
* 为每个表指定别名，并在查询中需要的地方使用该别名

可以使用`as`关键字对列或表的别名

### 3.5 where 子句

> where 子句用于在结果集中过滤掉不需要的行

### 3.7 order by子句

> **order by**  子句用于对结果集中的原始列数据或是根据列数据计算的表达式结果进行排序

#### 3.7.1 升序或降序排序

在排序时，可以通过关键字 `asc` 和 `desc` 指定时升序还是降序。默认情况是升序排序

```sql
SELECT account_id , product_cd ,open_date,avail_balance 
FROM account 
ORDER BY avail_balance DESC 
```

#### 3.7.2 根据表达式排序

栗子：根据客户的联邦个人识别号码（通常是个人的社会安全号码或是企业的公司号）的最后3位数字进行排序

```sql
SELECT cust_id ,cust_type_cd ,city,state,fed_id
FROM customer
ORDER BY RIGHT(fred_id,3)
```

right() 为内建函数，提取fed_id列的最后是三个字符，并根据该值对返回的行排序

#### 3.7.3  根据数字占位符排序

栗子：假设需要根据查询返回的第2个和第5个列排序

```sql
SELECT emp_id, title ,start_date, fname, lname
FROM employee
ORDER BY 2,5
```

##### **警告**

在单独的查询语句中使用列的顺序号，但是在写程序时应当总是使用名称来引用列

## **4  过滤**

本章为select 、update 和 delete语句中的where子句所能使用的各种类型的过滤条件，而对having 子句中过滤条件的使用转至 `8 分组与聚集`



### 4.1 条件评估

> where 子句可能包含1个或多个条件，每个条件之间用操作符 `and` 和`or`分割。
>
> 如果多个条件只使用`and`操作符分割，那么只有所有条件赋值都为true的行才可以被包含奥结果集之中。
>
> 如果where 子句中的所有条件是用 `or` 操作符分割的，那么只要其中一个条件成立，相应行就可以被包含到结果集中。

#### 4.1.1 使用圆括号

> 如果where子句包含了3个或更多条件，且同时使用了 `and` 和 `or` 操作符，那么需要使用圆括号来明确意图，以使数据库服务器或者以后可能阅读你代码的其他开发这能够理解

#### 4.1.2 使用 not 操作符

> 对于数据库服务器来说，处理包含not操作符的where子句毫不费力，但对于开发者来说，增加了对条件评估的困难，这也是通常情况下较少使用它的原因。应尽量避免使用not操作符

### 4.2 构建条件

条件通常由1个或多个包含1个到多个操作符的表达式构成。表达式可以是下面的类型中的任意一个。

| 表达式       |
| ------------ |
| 数字         |
| 表或视图中列 |
| 字符串       |
| 内建函数     |
| 子查询       |
| 表达式列表   |
| 比较操作符   |
| 算术操作符   |

### 4.3 条件类型

#### 4.3.1 相等条件

#### 4.3.2 范围条件

`between`  操作符

> 当需要同时限制范围的上限和下限时，可以选择使用between 操作符构建一个查询条件，而不需要两个单独的限制条件

##### **警告**

使用 `between` 操作符时，需要注意下面的事项，即必须首先指定方位的下限（在between 后面），然后指定范围的上限（在and 后面）。如果错误地指定了它们出现的次序，则会出现 `Empty set`

服务端会根据该条件产生两个使用<=和>=操作符的条件，所以上限和下限的位置不能弄错。

#### 4.3.3 成员条件

##### **使用`in`操作符**

##### **使用子查询**

##### **使用 `not in`**

检查一个表达式是否在某个表达式集合中存在，但有时侯需要检查的是它是否不存在

#### 4.3.4 匹配条件

##### **使用通配符**

根据部分字符串匹配进行搜索时。感兴趣的项目可能包括：

* 以某个字符开始（或结束）的字符串
* 包含某个子字符串的字符串
* 在字符串的任意位置包含某个字符的字符串
* 在字符串的任意位置包含某个子字符串的字符串
* 具备特定格式而不关心单个字符的字符串

| 通配符 | 匹配                    |
| ------ | ----------------------- |
| _      | 正好一个字符            |
| %      | 任意数目的字符（包括0） |

当使用搜索表达式构建条件时，可以使用like操作符

```sql
SELECT lname
FROM employee
WHERE lname LIKE '_a%e%'
```

上例的搜索表达式指定字符串的第二个位置必须为字符a，e必须在其后的任何位置（包括最后一个位置）中至少出现一次。

##### **搜索表达式示例**

| 搜索表达式           | 解释                                         |
| -------------------- | -------------------------------------------- |
| F%                   | 以F打头的字符串                              |
| %t                   | 以t结尾的字符串                              |
| %bas%                | 包含‘bas’子字符串的字符串                    |
| _ _ t _              | 包含4个字符，且第3个字符为 t 的字符串        |
| _ _ _ -_ _ - _ _ _ _ | 包含11个字符且第4和第7个字符为破折号的字符串 |

##### **使用正则表达式**

如果带通配符的字符串仍然不能提供足够的灵活性，那么可以使用正则表达式来构造搜索表达式。正则表达式实质上也是一种特殊的搜索表达式。有关正则表达式可参考Jeffrey E.F.Friedl 的 `Mastering Regular Expression`

```sql
SELECT emp_id, fname, lname  
FROM  employee
WHERE lname REGEXP '^[FG]'
```

regexp` 操作符接受一个正则表达式（本例中为 '^[FG]' ）

### 4.4 **null** :4 个字母的关键字

**null** 的适用场合：

* 没有合适的值 （比如ATM机上的自助交易并不需要employee ID 列）
* 值未确定 （比如在客户行被创建时还不知道他的 federal ID）
* 值未定义 （比如为某个还未添加到数据库的产品创建账户）

##### **警告**

* 当使用 **null** ，表达式可以为null，但不能等于 **null**
* 两个null 值彼此不能判断为相等

测试表达式是否为null，需要使用null操作符

```sql
SELECT emp_id, fname, lname, superior_emp_id
FROM employee
WHERE superior_emp_id IS NULL 
```

检查列中数据是否被赋值，可以使用 `not null` 操作符

## 5 多表查询

### 5.1 什么是连接

#### 5.1.1 笛卡尔积 

```sql
SELECT e.fname, e.lname,d.name
FROM employee e
JOIN department d 
```

上述连接称为交叉连接（cross join ），会产生两张表的所有置换，会造成数据重复。这是产生笛卡尔积的一个简单栗子，交叉连接在实际应用中很少使用。

#### 5.1.2 内连接

```sql
SELECT e.fname,e.lname,d.name 
FROM employee e 
INNER JOIN  department d
ON e.dept_id = d.dept_id
```

上述连接称为内连接，会减少交叉连接的重复记录，两个关键字 inner 显示指定连接类型，on子句提示数据库服务器 表 的连接方式

> 如果一个表中的dept_列中存在某个值，但该值在另一张表的dept_id列中不存在，那么相关行的连接会失败，在结果集中将会排除包含该值的行。这种类型的连接被称为内连接，也是最常用的一种连接类型。通常在对两个表使用内连接时，最好在from子句中显示指定连接类型。

##### 警告

如果并没有指定连接类型，那么服务器将会默认使用内连接。如果连接两个表的列名时相同的，如前一个栗子中的情况，那么可以使用using子句替代on子句。上述栗子改动如下

```sql
SELECT e.fname , e.lname, d.name
FROM employee e 
INNER JOIN department d 
USING (dept_id)
```

##### 警告

using 实际上只能在某些特殊情况下起到简化语法的作用，因此建议最好始终使用on子句以避免不一致的用法造成的困扰。

5.1.3 ANSI 连接语法

旧式的连接方法并不包含on子句，而是在from子句中定义各表的别名，并使用逗号隔开，然后再where子句中博阿寒连接条件，举个栗子

```sql
SELECT e.fname, e.lname, d.name 
FROM employee e ,department d 
WHERE e.dept_id = d.dept_id
```

SQL92连接语法，ANSI连接语法具备一下优点

* 连接条件和过滤条件被分隔到两个子句中（on子句和where子句），使查询语句更易于理解
* 每两个表之间的连接条件都在它们的on子句中列出，这样不容易错误地忽略了某些连接条件
* 使用SQL92连接语法地查询语句可以在各种数据库服务器中通用，而旧的语法在不同的服务器上的表现可能略有不同。
* SQL92 连接语法的优势在同时包含连接和过滤条件的复杂查询中表现得更明显

旧的连接语法与SQL92连接语法 对比

旧的连接语法

```sql
SELECT a.account_id, a.cust_id, a.open_date, a.product_cd
FROM account a ,branch b,employee e
WHERE  a.open_emp_id = e.emp_id 
AND e.start_date < '2007-01-01'
AND (e.title = 'Teller ') OR e.title = 'Head Teller'
AND b.name = 'Woburn Branch'
```

SQL92 连接语法

```sql
SELECT a.account_id, a.cust_id, a.open_date, a.product_cd
FROM account a
INNER JOIN employee e
ON a.open_emp_id = e.emp_id
INNER JOIN branch b
ON e.assigned_branch_id = b.branch_id
WHERE e.start_date < '2017-01-01'
AND (e.title = 'Teller ') OR e.title = 'Head Teller'
AND b.name = 'Woburn Branch'
```

### 5.2  连接3个或更多的表

更多的表以及更多的连接类型和on子句

##### 连接的顺序很重要么？

> SQL是一种非过程化的语言，也就是说只需要描述要获取的数据库对象，而如何以最好的方式执行查询则有由数据库服务器负责。服务器根据所收集的数据库对象信息，在3个表中选择一个作为开始点（所选择的表被称为驱动表），然后确定连接其他表的顺序，因此，在from子句中各表出现的顺序并不重要。
>
> 不过如果你需要在查询中以特定的顺序连接各表，那么需要将表按照所需要的顺序排列好，然后指定MYSQL中的`STRAIGHT_JOIN`关键字,或者SQL server中FORCEORDER 选项，或者在Oracle 数据中使用ORDERED 或 LEADING 优化器提示。

#### 5.2.1  将子查询结果作为查询表

第九章详细介绍子查询主题

```sql
SELECT a.account_id, a.cust_id, a.open_date, a.product_cd
FROM account a 
INNER JOIN (
			SELECT emp_id, assigned_branch_id
			FROM employee
			WHERE start_date < '2007-01-01'
			AND (e.title = 'Teller ') OR e.title = 'Head Teller') e
ON a.open_emp_id  = e.emp_id
INNER JOIN (
    		SELECT branch_id 
			FROM branch 
			WHERE name = 'Woburn Branch') b
ON e.assigned_branch_id = b.branch_id

```

#### 5.2.2 连续两次使用同一个表

如果在一次sql中，在from子句中两次引用同一张表，为了使之正常工作，需要给每个branch的表的实例定义不同的别名，以便服务器能够在各子句中正确的引用它们。举个栗子

```sql
SELECT a.account_id , e.emp_id,
b_a.name open_branch ,b_e.name emp_branch
FROM account a
INNER JOIN branch b_a
on a.open_emp_id = e.emp_id
INNER JOIN branch b_e 
ON e.assigned_branch_id = b.branch_id
WHERE a.product_cd = 'CHK'
```

### 5.3 自连接

不仅可以在同一查询中多次包含同一个表，还可以对表自身进行连接。

注：使用自连接，该表需要包含一个指向自身的外键。

### 5.4  相等连接和不等连接

### 5.5 连接条件和过滤条件

